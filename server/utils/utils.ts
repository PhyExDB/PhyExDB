import { validate as uuidValidate } from "uuid"
import type { H3Event, EventHandlerRequest } from "h3"
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library"

/**
 * Consumes a value of type T without performing any operations.
 * This is a no-op function that essentially ignores its input.
 *
 * @param _ - The value to consume.
 */
export function consume<T>(_: T) {
  // empty
}

/**
 * Type of Event given to Endpoints
 */
export type Event = H3Event<EventHandlerRequest>

/**
 * Generates a Prisma where clause based on a slug or ID parameter from the event.
 */
export function getSlugOrIdPrismaWhereClause(event: Event): { slug: string } | { id: string } {
  const slugOrId = getRouterParam(event, "slug")
  if (!slugOrId) {
    throw createError({ status: 400, message: "Invalid slug" })
  }

  const isId = uuidValidate(slugOrId)
  const whereClause = isId ? { id: slugOrId } : { slug: slugOrId }
  return whereClause
}

/**
 * Generates a Prisma where clause based on an ID parameter from the event.
 */
export function getIdPrismaWhereClause(event: Event) {
  const id = getRouterParam(event, "id")
  if (!id) {
    throw createError({ status: 400, message: "Invalid id" })
  }

  const whereClause = { id: id }
  return whereClause
}

/**
 * Executes a given asynchronous function and catches Prisma unique constraint errors.
 * If a unique constraint error occurs on the specified attribute, it returns "NOTUNIQUE".
 * Otherwise, it returns the result of the function or rethrows any other errors.
 */
export async function catchPrismaUniqueError<T>(
  call: () => Promise<T>,
  attribute: string,
): Promise<T | "NOTUNIQUE"> {
  try {
    return await call()
  } catch (error) {
    if (error instanceof PrismaClientKnownRequestError) {
      if (error.code === "P2002"
        && error.meta?.target && error.meta?.target instanceof Array
        && error.meta.target.includes(attribute)) {
        return "NOTUNIQUE"
      } else {
        throw error
      }
    } else {
      throw error
    }
  }
}

/**
 * Ensures that a unique slug is generated by appending a suffix to the base slug until a unique slug is found.
 */
export async function untilSlugUnique<T>(
  call: (slug: string) => Promise<T>,
  slugBase: string,
  slugSuffix: number = 1,
): Promise<T> {
  let result: T | undefined | "NOTUNIQUE" = "NOTUNIQUE"
  while (result === "NOTUNIQUE") {
    result = await catchPrismaUniqueError(() => call(slugBase + (slugSuffix === 1 ? "" : slugSuffix)), "slug")
    slugSuffix++
  }
  return result
}
